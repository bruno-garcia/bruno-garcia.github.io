<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pitfalls of Unoptimized NuGet Packages | Bruno Garcia's blog</title><meta name=keywords content=".NET,Assembly,NuGet,Optimization"><meta name=description content="Avoid using unoptimized .NET assemblies with UnoptimizedAssemblyDetector."><meta name=author content="Bruno Garcia"><link rel=canonical href=https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/><link href=https://garcia.in/assets/css/stylesheet.min.9544fd6674ce811c7326986891f234a4c6eb798ea550b036754f0bca70c49f3b.css integrity="sha256-lUT9ZnTOgRxzJphokfI0pMbreY6lULA2dU8LynDEnzs=" rel="preload stylesheet" as=style><link rel=icon href=https://garcia.in/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://garcia.in/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://garcia.in/favicon-32x32.png><link rel=apple-touch-icon href=https://garcia.in/apple-touch-icon.png><link rel=mask-icon href=https://garcia.in/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.79.1"><link href=https://garcia.in/assets/css/custom_blog.min.7298d009bdbcc5c0dad21993cd67b42de34ddb29b145cf2557a3f1d4e613ee2b.css integrity="sha256-cpjQCb28xcDa0hmTzWe0LeNN2ymxRc8lV6Px1OYT7is=" rel="preload stylesheet" as=style><script src=https://browser.sentry-cdn.com/6.4.1/bundle.tracing.min.js integrity=sha384-hddl7X3flGhIMJgLUpwZDzLOWf8GDApKvKos/jS4z7Uz/sejXA0thkp9JCZgoDG4 crossorigin=anonymous></script><script>Sentry.init({dsn:"https://88e8d79d263e44f0b6e3c3745244ce9c@o117736.ingest.sentry.io/5778766",integrations:[new Sentry.Integrations.BrowserTracing()],tracesSampleRate:1.0,});</script><meta property="og:title" content="Pitfalls of Unoptimized NuGet Packages"><meta property="og:description" content="Avoid using unoptimized .NET assemblies with UnoptimizedAssemblyDetector."><meta property="og:type" content="article"><meta property="og:url" content="https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/"><meta property="og:image" content="https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/snail-cover.jpg"><meta property="article:published_time" content="2021-05-21T16:20:00-04:00"><meta property="article:modified_time" content="2021-05-21T16:20:00-04:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/snail-cover.jpg"><meta name=twitter:title content="Pitfalls of Unoptimized NuGet Packages"><meta name=twitter:description content="Avoid using unoptimized .NET assemblies with UnoptimizedAssemblyDetector."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Pitfalls of Unoptimized NuGet Packages","name":"Pitfalls of Unoptimized NuGet Packages","description":"Summary You might unknowingly be using an unoptimized dependency which could impact the performance of your app. Now, it\u0026amp;rsquo;s easy to get a warning if that happens, at build …","keywords":[".NET","Assembly","NuGet","Optimization"],"articleBody":"Summary You might unknowingly be using an unoptimized dependency which could impact the performance of your app. Now, it’s easy to get a warning if that happens, at build time, using the NuGet package UnoptimizedAssemblyDetector:\n Include=\"UnoptimizedAssemblyDetector\" Version=\"0.1.0\" all  After you add this NuGet package, a warning will be included in your build if any unoptimized assembly is detected.\n\nThe source code of project is hosted on GitHub ⭐.\nWhat’s the pitfall? The default build configuration for dotnet pack and dotnet publish is not Release as you might assume or expect. When publishing NuGet packages to nuget.org, one must explicitly make it a release package, like: dotnet pack -c Release. Without it, the assemblies packed will not be compiled with optimizations. In this blog post you’ll learn that’s not always the case. Even for those who know, accidents happens and a misconfigured build script can result in a Debug build ending up on nuget.org.\nThe default value being Debug, which results in unoptimized assemblies, isn’t alone the reason why this is a pitfall. There’s no warning of any kind from the point you create the NuGet package, through uploading to nuget.org all the way to restoring it for your project.\nWhy should I care? If you don’t need convincing, feel free to skip ahead to Sensible defaults.\nBenchmarks No pitfalls when running BenchmarkDotNet in debug mode. It stops you quickly:\n➜ dotnet run // Validating benchmarks: Assembly UnoptimizedBenchmarks which defines benchmarks is non-optimized Benchmark was built without optimization enabled (most probably a DEBUG configuration). Please, build it in RELEASE. If you want to debug the benchmarks, please see https://benchmarkdotnet.org/articles/guides/troubleshooting.html#debugging-benchmarks. We can force it by using DebugBuildConfig and to illustrate some of the differences between Release and Debug builds, I adapted a Fibonacci benchmark from this blog post to compare the two:\nusing System.Collections.Generic; using System.Linq; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; var summary = BenchmarkRunner.Run(typeof(FibonacciBenchmark).Assembly #if DEBUG ,new BenchmarkDotNet.Configs.DebugBuildConfig() #endif ); public class FibonacciBenchmark { [Params(1, 2, 3, 5, 8, 13, 21, 34)] public int Count { get; set; } [Benchmark] public void Fibonacci() = _ = GetFibonacci(Count).ToList(); IEnumerable GetFibonacci(int count) { var w = 1; var x = 1; yield return x; foreach (var _ in Enumerable.Range(1, count - 1)) { var y = w + x; yield return y; w = x; x = y; } } } Debug run ➜ dotnet run -c Debug BenchmarkDotNet=v0.13.0, OS=macOS Big Sur 11.2.3 (20D91) [Darwin 20.3.0] Intel Core i7-9750H CPU 2.60GHz, 1 CPU, 12 logical and 6 physical cores .NET SDK=6.0.100-preview.3.21202.5 [Host] : .NET 6.0.0 (6.0.21.20104), X64 RyuJIT DefaultJob : .NET 6.0.0 (6.0.21.20104), X64 RyuJIT BuildConfiguration=Debug | Method | Count | Mean | Error | StdDev | |---------- |------ |----------:|---------:|---------:| | Fibonacci | 1 | 83.99 ns | 1.271 ns | 0.992 ns | | Fibonacci | 2 | 109.46 ns | 1.460 ns | 1.366 ns | | Fibonacci | 3 | 124.59 ns | 0.903 ns | 0.845 ns | | Fibonacci | 5 | 172.64 ns | 0.930 ns | 0.726 ns | | Fibonacci | 8 | 213.29 ns | 1.019 ns | 0.851 ns | | Fibonacci | 13 | 315.48 ns | 2.518 ns | 2.103 ns | | Fibonacci | 21 | 470.91 ns | 2.907 ns | 2.719 ns | | Fibonacci | 34 | 687.77 ns | 7.792 ns | 6.507 ns | Release run ➜ dotnet run -c Release | Method | Count | Mean | Error | StdDev | |---------- |------ |----------:|---------:|---------:| | Fibonacci | 1 | 60.52 ns | 0.436 ns | 0.364 ns | | Fibonacci | 2 | 81.21 ns | 0.465 ns | 0.388 ns | | Fibonacci | 3 | 93.38 ns | 0.575 ns | 0.449 ns | | Fibonacci | 5 | 133.85 ns | 0.969 ns | 0.809 ns | | Fibonacci | 8 | 167.17 ns | 2.574 ns | 3.161 ns | | Fibonacci | 13 | 242.88 ns | 1.877 ns | 1.567 ns | | Fibonacci | 21 | 369.98 ns | 5.940 ns | 5.556 ns | | Fibonacci | 34 | 572.87 ns | 8.560 ns | 8.007 ns | It’s clear that compiling in Release mode significantly affects the performance of this benchmark. How much that affects your app? You’d need to measure it. It’s possible that for your app it doesn’t result in any noticeable slow downs. But it possibly can.\nOptimizations  Never use the Debug build for benchmarking. Never. The debug version of the target method can run 10–100 times slower.\n This came from BenchmarkDotNet’s Good Practices documentation. The impact that it causes to your application might not be as severe or noticeable. Ironically, benchmarking is one of the tools to measure that.\nThe C# compiler docs state:\n The Optimize option enables or disables optimizations performed by the compiler to make your output file smaller, faster, and more efficient. The Optimize option is enabled by default for a Release build configuration. It is off by default for a Debug build configuration.\n To go more in depth into what kinds of optimizations are done, lets refer to Eric Lippert, former Principal Engineer in the C# language design team and his blog post on the subject. Which we can read thanks to web.archive.org:\n Expressions which are determined to be only useful for their side effects are turned into code that merely produces the side effects. We omit generating code for things like int foo = 0; because we know that the memory allocator will initialize fields to default values. We omit emitting and generating empty static class constructors. (Which typically happens if the static constructor set all the fields to their default value and the previous optimization eliminated all of them.) We omit emitting a field for any hoisted locals that are unused in an iterator block. (This includes that case where the local in question is used only inside an anonymous function in the iterator block, in which case it is going to become hoisted into a field of the closure class for the anonymous function. No need to hoist it twice if we don’t need to.) We attempt to minimize the number of local variable and temporary slots allocated. For example, if you have:  for (int i = …) {…} for (int i = …) {…} then the compiler could generate code to re-use the local variable storage reserved for i when the second i comes along. (We eschew this optimization if the locals have different names because then it gets hard to emit sensible debug info, which we still want to do even for the optimized build. However, the jitter is free to perform this optimization if it wishes to.)\n Also, if you have a local which is never used at all, then there is no storage allocated for it if the flag is set. Similarly, the compiler is more aggressive about re-using the unnamed temporary slots sometimes used to store results of subexpression calculations. Also, with the flag set the compiler is more aggressive about generating code that throws away “temporary” values quickly for things like controlling variables of switch statements, the condition in an “if” statement, the value being returned, and so on. In the non-optimized build these values are treated as unnamed local variables, loaded from and stored to specific locations. In the optimized build they can often be just kept on the stack proper. We eliminate pretty much all of the “breakpoint convenience” no-ops. If a try block is empty then clearly the catch blocks are not reachable and can be trimmed. (Finally blocks of empty tries are preserved as protected regions because they have unusual behaviour when faced with certain exceptions; see the comments for details.) If we have an instruction which branches to LABEL1, and the instruction at LABEL1 branches to LABEL2, then we rewrite the first instruction as a branch straight to LABEL2. Same with branches that go to returns. We look for “branch over a branch” situations. For example, here we go to LABEL1 if condition is false, otherwise we go to LABEL2.  brfalse condition, LABEL1 br LABEL2 LABEL1: somecode Since we are simply branching over another branch, we can rewrite this as simply “if condition is true, go to LABEL2\":\nbrtrue condition, LABEL2 somecode  We look for “branch to nop” situations. If a branch goes to a nop then you can make it branch to the instruction after the nop. We look for “branch to next” situations; if a branch goes to the next instruction then you can eliminate it. We look for two return instructions in a row; this happens sometimes and obviously we can turn it into a single return instruction.  This text was written a long time ago. And since this writing, Eric Lippert left Microsoft and the C# compiler was rewritten and open sourced. You can browse Roslyn’s repository and you’ll discover that new optimizations are still being suggested and added.\nSensible defaults I’ve been talking about packaging NuGet with Release configuration then talking about Roslyn optimization. These two things are not exactly the same (though by default related) and I wish to clarify.\nThe Release configuration, by default does provide the -optimize+ flag to the C# compiler but you can achieve the same for example by means of a MSBuild property true. I hope the quote from the docs I include help make this clear.\n Optimize also tells the common language runtime to optimize code at runtime. By default, optimizations are disabled. Specify Optimize+ to enable optimizations. When building a module to be used by an assembly, use the same Optimize settings as used by the assembly. It’s possible to combine the Optimize and Debug options.\n This passage from the C# compiler docs isn’t something new, and there has been a lot of debate about whether the default should be changed to Release.\nRelease as default \nTo me, it sounded pretty obvious at first that this should the right thing to do. As it did for a lot of folks on that thread. But it turns out the .NET team has strong and valid opinions to why that shouldn’t be the case.\n\nDebug builds on nuget.org Regardless of which side of the debate you stand, the truth of the matter is that we’re left with packages being published to nuget.org with assemblies compiled without optimization.\nStructureMap 4.4.1 is up. No code changes, but corrects the problem of the nuget being built as Debug for 4.3.0 and 4.4.0. Oops on my part.\n— jeremydmiller (@jeremydmiller) September 18, 2016  I knew this would happen. I've done it myself and you won't be the last. More debug builds on NuGet ahead. @davidfowl\n— Kristian Hellang (@khellang) September 19, 2016   I feel like publishing packages to nuget.org relates a lot to sailing and running aground:\n There are three kinds of skippers, those who have run aground, those who will run aground, and those that have but won’t admit it.\n Replace skippers with package authors and running aground with publish packages built in debug and there you have it.\nPublishing unoptimized bits also happened to Sentry’s SharpRaven SDK back in 2018. If you’re using SharpRaven version 2.3.0, you’re running an unoptimized assembly. I would recommend you upgrade it to 2.3.1 but on that same year that package was replaced by Sentry. Don’t worry, it’s packaged in release mode. Not that you should take my word for it.\nIn early 2020, I even opened a PR to add this verification to the Sentry SDK for .NET so it would check assemblies being loaded whether they were optimized or not, and send events to Sentry when applicable. But it never felt like the right thing to do. This verification must happen much earlier, at latest during build time. For this reason UnoptimizedAssemblyDetector was born.\nMy days are numbered That’s a gloomy heading. It’s the UnoptimizedAssemblyDetector NuGet package talking though, not me. I built this package in hopes for it to become obsolete one day. Not because I expect the default of dotnet pack to ever change. Clearly it won’t. But I believe such warnings should be part of NuGet itself.\nWhen you push a NuGet package to nuget.org, it should verify if the managed assemblies under lib/ are indeed compiled with optimization, and if not, it should warn the author. At the same time, when restoring such package, it should warn the consumer. This part in particular will make UnoptimizedAssemblyDetector redundant.\nWhat else can we do? NuGet Trends has the complete catalog. It could be extended to download the packages and inspect the assemblies in them. With that, create graphs and expose an endpoint to list unoptimized assemblies.\nWell that, and ask the NuGet team to add these checks during package upload/restore.\n– Cover photo by amirali mirhashemian on Unsplash ","wordCount":"2134","inLanguage":"en","image":"https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/snail-cover.jpg","datePublished":"2021-05-21T16:20:00-04:00","dateModified":"2021-05-21T16:20:00-04:00","author":{"@type":"Person","name":"Bruno Garcia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/"},"publisher":{"@type":"Organization","name":"Bruno Garcia's blog","logo":{"@type":"ImageObject","url":"https://garcia.in/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://garcia.in accesskey=h title="Bruno Garcia's blog (Alt + H)">Bruno Garcia's blog</a>
<span class=logo-switches><span class=theme-toggle title="(Alt + T)"><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Pitfalls of Unoptimized NuGet Packages</h1></header><figure class=entry-cover><img srcset="https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/snail-cover_hubd431eae1df241621695317530e226f7_1805892_360x0_resize_q75_box.jpg 360w ,https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/snail-cover_hubd431eae1df241621695317530e226f7_1805892_480x0_resize_q75_box.jpg 480w ,https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/snail-cover_hubd431eae1df241621695317530e226f7_1805892_720x0_resize_q75_box.jpg 720w ,https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/snail-cover_hubd431eae1df241621695317530e226f7_1805892_1080x0_resize_q75_box.jpg 1080w ,https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/snail-cover_hubd431eae1df241621695317530e226f7_1805892_1500x0_resize_q75_box.jpg 1500w ,https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/snail-cover.jpg 4929w" sizes="(min-width: 768px) 720px, 100vw" src=https://garcia.in/posts/2021/pitfalls-of-unoptimzied-nuget-packages/snail-cover.jpg alt="A Snail."></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><blockquote><ul><li><a href=#summary aria-label=Summary>Summary</a></li><li><a href=#whats-the-pitfall aria-label="What&amp;rsquo;s the pitfall?">What&rsquo;s the pitfall?</a></li><li><a href=#why-should-i-care aria-label="Why should I care?">Why should I care?</a><ul><li><a href=#benchmarks aria-label=Benchmarks>Benchmarks</a><ul><li><a href=#debug-run aria-label="Debug run">Debug run</a></li><li><a href=#release-run aria-label="Release run">Release run</a></li></ul></li><li><a href=#optimizations aria-label=Optimizations>Optimizations</a></li></ul></li><li><a href=#sensible-defaults aria-label="Sensible defaults">Sensible defaults</a><ul><li><a href=#release-as-default aria-label="Release as default">Release as default</a></li></ul></li><li><a href=#debug-builds-on-nugetorg aria-label="Debug builds on nuget.org">Debug builds on nuget.org</a></li><li><a href=#my-days-are-numbered aria-label="My days are numbered">My days are numbered</a></li></ul></blockquote></details></div><div class=post-content><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>You might unknowingly be using an unoptimized dependency which could impact the performance of your app.
Now, it&rsquo;s easy to get a warning if that happens, at build time,
using the NuGet package <a href=https://www.nuget.org/packages/UnoptimizedAssemblyDetector/><code>UnoptimizedAssemblyDetector</code></a>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=color:#f92672>&lt;PackageReference</span> <span style=color:#a6e22e>Include=</span><span style=color:#e6db74>&#34;UnoptimizedAssemblyDetector&#34;</span> <span style=color:#a6e22e>Version=</span><span style=color:#e6db74>&#34;0.1.0&#34;</span><span style=color:#f92672>&gt;</span>
  <span style=color:#f92672>&lt;PrivateAssets&gt;</span>all<span style=color:#f92672>&lt;/PrivateAssets&gt;</span>
<span style=color:#f92672>&lt;/PackageReference&gt;</span>
</code></pre></div><p>After you add this NuGet package, a warning will be included in your build if any unoptimized assembly is detected.</p><p><a href=unoptimized-assembly-detected.gif><img src=unoptimized-assembly-detected.gif alt=unoptimized-assembly-detected></a></p><p>The source code of project is <a href=https://github.com/bruno-garcia/unoptimized-assembly-detector>hosted on GitHub</a> ⭐.</p><h2 id=whats-the-pitfall>What&rsquo;s the pitfall?<a hidden class=anchor aria-hidden=true href=#whats-the-pitfall>#</a></h2><p>The default build configuration for <code>dotnet pack</code> and <code>dotnet publish</code> is not <code>Release</code> as you might assume or expect.
When publishing NuGet packages to <em>nuget.org</em>, one must explicitly make it a release package, like: <code>dotnet pack -c Release</code>. Without it, the assemblies packed will not be compiled with optimizations.
In this blog post you&rsquo;ll learn that&rsquo;s not always the case. Even for those who know, accidents happens and a misconfigured build script can result in a <code>Debug</code> build ending up on <em>nuget.org</em>.</p><p>The default value being <code>Debug</code>, which results in unoptimized assemblies, isn&rsquo;t alone the reason why this is a pitfall.
There&rsquo;s no warning of any kind from the point you create the NuGet package, through uploading to <em>nuget.org</em> all the way to restoring it for your project.</p><h2 id=why-should-i-care>Why should I care?<a hidden class=anchor aria-hidden=true href=#why-should-i-care>#</a></h2><p>If you don&rsquo;t need convincing, feel free to skip ahead to <a href=#sensible-defaults>Sensible defaults</a>.</p><h3 id=benchmarks>Benchmarks<a hidden class=anchor aria-hidden=true href=#benchmarks>#</a></h3><p>No pitfalls when running <code>BenchmarkDotNet</code> in debug mode. It stops you quickly:</p><pre><code>➜ dotnet run
// Validating benchmarks:
Assembly UnoptimizedBenchmarks which defines benchmarks is non-optimized
Benchmark was built without optimization enabled (most probably a DEBUG configuration). Please, build it in RELEASE.
If you want to debug the benchmarks, please see https://benchmarkdotnet.org/articles/guides/troubleshooting.html#debugging-benchmarks.
</code></pre><p>We can force it by using <code>DebugBuildConfig</code> and to illustrate some of the differences between <code>Release</code> and <code>Debug</code> builds,
I adapted a Fibonacci benchmark <a href=https://dev.to/newday-technology/measuring-performance-using-benchmarkdotnet-part-1-39g3>from this blog post</a> to compare the two:</p><pre><code>using System.Collections.Generic;
using System.Linq;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

var summary = BenchmarkRunner.Run(typeof(FibonacciBenchmark).Assembly 
#if DEBUG
    ,new BenchmarkDotNet.Configs.DebugBuildConfig()
#endif
    );

public class FibonacciBenchmark
{
    [Params(1, 2, 3, 5, 8, 13, 21, 34)]
    public int Count { get; set; }

    [Benchmark]
    public void Fibonacci() =&gt; _ = GetFibonacci(Count).ToList();
    
    IEnumerable&lt;int&gt; GetFibonacci(int count)
    {
        var w = 1; var x = 1;

        yield return x;
        foreach (var _ in Enumerable.Range(1, count - 1))
        {
            var y = w + x;
            yield return y;
            w = x;
            x = y;
        }
    }
}
</code></pre><h4 id=debug-run>Debug run<a hidden class=anchor aria-hidden=true href=#debug-run>#</a></h4><pre><code>➜ dotnet run -c Debug

BenchmarkDotNet=v0.13.0, OS=macOS Big Sur 11.2.3 (20D91) [Darwin 20.3.0]
Intel Core i7-9750H CPU 2.60GHz, 1 CPU, 12 logical and 6 physical cores
.NET SDK=6.0.100-preview.3.21202.5
  [Host]     : .NET 6.0.0 (6.0.21.20104), X64 RyuJIT
  DefaultJob : .NET 6.0.0 (6.0.21.20104), X64 RyuJIT

BuildConfiguration=Debug  

|    Method | Count |      Mean |    Error |   StdDev |
|---------- |------ |----------:|---------:|---------:|
| Fibonacci |     1 |  83.99 ns | 1.271 ns | 0.992 ns |
| Fibonacci |     2 | 109.46 ns | 1.460 ns | 1.366 ns |
| Fibonacci |     3 | 124.59 ns | 0.903 ns | 0.845 ns |
| Fibonacci |     5 | 172.64 ns | 0.930 ns | 0.726 ns |
| Fibonacci |     8 | 213.29 ns | 1.019 ns | 0.851 ns |
| Fibonacci |    13 | 315.48 ns | 2.518 ns | 2.103 ns |
| Fibonacci |    21 | 470.91 ns | 2.907 ns | 2.719 ns |
| Fibonacci |    34 | 687.77 ns | 7.792 ns | 6.507 ns |
</code></pre><h4 id=release-run>Release run<a hidden class=anchor aria-hidden=true href=#release-run>#</a></h4><pre><code>➜ dotnet run -c Release


|    Method | Count |      Mean |    Error |   StdDev |
|---------- |------ |----------:|---------:|---------:|
| Fibonacci |     1 |  60.52 ns | 0.436 ns | 0.364 ns |
| Fibonacci |     2 |  81.21 ns | 0.465 ns | 0.388 ns |
| Fibonacci |     3 |  93.38 ns | 0.575 ns | 0.449 ns |
| Fibonacci |     5 | 133.85 ns | 0.969 ns | 0.809 ns |
| Fibonacci |     8 | 167.17 ns | 2.574 ns | 3.161 ns |
| Fibonacci |    13 | 242.88 ns | 1.877 ns | 1.567 ns |
| Fibonacci |    21 | 369.98 ns | 5.940 ns | 5.556 ns |
| Fibonacci |    34 | 572.87 ns | 8.560 ns | 8.007 ns |
</code></pre><p>It&rsquo;s clear that compiling in <code>Release</code> mode significantly affects the performance of this benchmark.
How much that affects your app? You&rsquo;d need to measure it. It&rsquo;s possible that for your app it doesn&rsquo;t result in any noticeable slow downs. But it possibly can.</p><h3 id=optimizations>Optimizations<a hidden class=anchor aria-hidden=true href=#optimizations>#</a></h3><blockquote><p>Never use the Debug build for benchmarking. Never. The debug version of the target method can run 10–100 times slower.</p></blockquote><p>This came from <a href=https://benchmarkdotnet.org/articles/guides/good-practices.html>BenchmarkDotNet&rsquo;s Good Practices</a> documentation. The impact that it causes to your application might not be as severe or noticeable. Ironically, benchmarking is one of the tools to measure that.</p><p>The <a href=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/code-generation#optimize>C# compiler docs</a> state:</p><blockquote><p>The Optimize option enables or disables optimizations performed by the compiler to make your output file smaller, faster, and more efficient. The Optimize option is enabled by default for a Release build configuration. It is off by default for a Debug build configuration.</p></blockquote><p>To go more in depth into what kinds of optimizations are done, lets refer to Eric Lippert, former Principal Engineer in the C# language design team and his blog post on the subject. <a href=https://web.archive.org/web/20110802071721/http://blogs.msdn.com/b/ericlippert/archive/2009/06/11/what-does-the-optimize-switch-do.aspx>Which we can read thanks to web.archive.org</a>:</p><ul><li>Expressions which are determined to be only useful for their side effects are turned into code that merely produces the side effects.</li><li>We omit generating code for things like <code>int foo = 0;</code> because we know that the memory allocator will initialize fields to default values.</li><li>We omit emitting and generating empty static class constructors. (Which typically happens if the static constructor set all the fields to their default value and the previous optimization eliminated all of them.)</li><li>We omit emitting a field for any hoisted locals that are unused in an iterator block. (This includes that case where the local in question is used only inside an anonymous function in the iterator block, in which case it is going to become hoisted into a field of the closure class for the anonymous function. No need to hoist it twice if we don’t need to.)</li><li>We attempt to minimize the number of local variable and temporary slots allocated. For example, if you have:</li></ul><pre><code>for (int i = …) {…}
for (int i = …) {…}
</code></pre><p>then the compiler could generate code to re-use the local variable storage reserved for <code>i</code> when the second <code>i</code> comes along. (We eschew this optimization if the locals have different names because then it gets hard to emit sensible debug info, which we still want to do even for the optimized build. However, the jitter is free to perform this optimization if it wishes to.)</p><ul><li>Also, if you have a local which is never used at all, then there is no storage allocated for it if the flag is set.</li><li>Similarly, the compiler is more aggressive about re-using the unnamed temporary slots sometimes used to store results of subexpression calculations.</li><li>Also, with the flag set the compiler is more aggressive about generating code that throws away “temporary” values quickly for things like controlling variables of switch statements, the condition in an “if” statement, the value being returned, and so on. In the non-optimized build these values are treated as unnamed local variables, loaded from and stored to specific locations. In the optimized build they can often be just kept on the stack proper.</li><li>We eliminate pretty much all of the “breakpoint convenience” no-ops.</li><li>If a try block is empty then clearly the catch blocks are not reachable and can be trimmed. (Finally blocks of empty tries are preserved as protected regions because they have unusual behaviour when faced with certain exceptions; see the comments for details.)</li><li>If we have an instruction which branches to <code>LABEL1</code>, and the instruction at <code>LABEL1</code> branches to <code>LABEL2</code>, then we rewrite the first instruction as a branch straight to <code>LABEL2</code>. Same with branches that go to returns.</li><li>We look for “branch over a branch” situations. For example, here we go to <code>LABEL1</code> if condition is false, otherwise we go to <code>LABEL2</code>.</li></ul><pre><code>brfalse condition, LABEL1
br LABEL2
LABEL1: somecode
</code></pre><p>Since we are simply branching over another branch, we can rewrite this as simply &ldquo;if condition is true, go to <code>LABEL2</code>":</p><pre><code>brtrue condition, LABEL2
somecode
</code></pre><ul><li>We look for “branch to nop” situations. If a branch goes to a nop then you can make it branch to the instruction after the nop.</li><li>We look for “branch to next” situations; if a branch goes to the next instruction then you can eliminate it.</li><li>We look for two return instructions in a row; this happens sometimes and obviously we can turn it into a single return instruction.</li></ul><p>This text was written a long time ago. And since this writing, Eric Lippert left Microsoft and the C# compiler was rewritten and open sourced.
You can browse <a href=http://github.com/dotnet/roslyn>Roslyn&rsquo;s</a> repository and you&rsquo;ll <a href="https://github.com/dotnet/roslyn/issues?q=is%3Aissue+is%3Aopen+optimization+proposal">discover that new optimizations are still being suggested</a> and added.</p><h2 id=sensible-defaults>Sensible defaults<a hidden class=anchor aria-hidden=true href=#sensible-defaults>#</a></h2><p>I&rsquo;ve been talking about packaging NuGet with <code>Release</code> configuration then talking about Roslyn optimization.
These two things are not exactly the same (though by default related) and I wish to clarify.</p><p>The <code>Release</code> configuration, by default does provide the <code>-optimize+</code> flag to the C# compiler
but you can achieve the same for example by means of a MSBuild property <code>&lt;Optimize>true&lt;/Optimize></code>.
I hope the quote from the docs I include help make this clear.</p><blockquote><p>Optimize also tells the common language runtime to optimize code at runtime. By default, optimizations are disabled. Specify Optimize+ to enable optimizations. When building a module to be used by an assembly, use the same Optimize settings as used by the assembly. It&rsquo;s possible to combine the Optimize and Debug options.</p></blockquote><p><a href=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/code-generation#optimize>This passage from the C# compiler docs</a> isn&rsquo;t something new, and there has been a lot of debate about whether the default should be changed to <code>Release</code>.</p><h3 id=release-as-default>Release as default<a hidden class=anchor aria-hidden=true href=#release-as-default>#</a></h3><p><a href=https://github.com/aspnet/dnx/pull/3204><img src=dnx-release-build-pack-dark.png alt="dnx issue release build for pack command"></a></p><p>To me, it sounded pretty obvious at first that this should the right thing to do. As it did for a lot of folks on that thread.
But it turns out the .NET team has strong and valid opinions to why that shouldn&rsquo;t be the case.</p><p><a href=https://github.com/aspnet/dnx/pull/3204#issuecomment-159985967><img src=davidfowl-nuget-package-debug-dark.png alt=davidfowl-nuget-package-debug></a></p><h2 id=debug-builds-on-nugetorg>Debug builds on nuget.org<a hidden class=anchor aria-hidden=true href=#debug-builds-on-nugetorg>#</a></h2><p>Regardless of which side of the debate you stand, the truth of the matter is that we&rsquo;re left with packages being published to <em>nuget.org</em> with assemblies compiled without optimization.</p><br><div align=center><blockquote class=twitter-tweet><p lang=en dir=ltr>StructureMap 4.4.1 is up. No code changes, but corrects the problem of the nuget being built as Debug for 4.3.0 and 4.4.0. Oops on my part.</p>&mdash; jeremydmiller (@jeremydmiller) <a href="https://twitter.com/jeremydmiller/status/777571510919630848?ref_src=twsrc%5Etfw">September 18, 2016</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><blockquote class=twitter-tweet><p lang=en dir=ltr>I knew this would happen. I've done it myself and you won't be the last. More debug builds on NuGet ahead. <a href="https://twitter.com/davidfowl?ref_src=twsrc%5Etfw">@davidfowl</a></p>&mdash; Kristian Hellang (@khellang) <a href="https://twitter.com/khellang/status/777753550491353088?ref_src=twsrc%5Etfw">September 19, 2016</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script></div><br><p>I feel like publishing packages to <em>nuget.org</em> relates a lot to sailing and running aground:</p><blockquote><p>There are three kinds of skippers, those who have run aground, those who will run aground, and those that have but won&rsquo;t admit it.</p></blockquote><p>Replace <em>skippers</em> with <em>package authors</em> and <em>running aground</em> with <em>publish packages built in debug</em> and there you have it.</p><p>Publishing unoptimized bits also happened to Sentry&rsquo;s <em>SharpRaven</em> SDK back in 2018. If you&rsquo;re using <a href=https://www.nuget.org/packages/SharpRaven/2.3.0>SharpRaven version 2.3.0</a>, you&rsquo;re running an unoptimized assembly. I would recommend you <a href=https://github.com/getsentry/raven-csharp/pull/226/files>upgrade it to 2.3.1</a> but on that same year that package was replaced by <a href=https://www.nuget.org/packages/Sentry/>Sentry</a>. Don&rsquo;t worry, it&rsquo;s <a href=https://github.com/getsentry/sentry-dotnet/blob/bc4c5e23eaaaa848a9a44ae05ac257a591624b24/build.ps1#L14>packaged in release mode</a>. Not that you should take my word for it.</p><p>In early 2020, I even <a href=https://github.com/getsentry/sentry-dotnet/pull/365/files>opened a PR to add this verification to the Sentry SDK for .NET</a> so it would check assemblies being loaded whether they were optimized or not, and send events to Sentry when applicable. But it never felt like the right thing to do. This verification must happen much earlier, at latest during build time. For this reason <a href=https://www.nuget.org/packages/UnoptimizedAssemblyDetector/><code>UnoptimizedAssemblyDetector</code></a> was born.</p><h2 id=my-days-are-numbered>My days are numbered<a hidden class=anchor aria-hidden=true href=#my-days-are-numbered>#</a></h2><p>That&rsquo;s a gloomy heading. It&rsquo;s the <code>UnoptimizedAssemblyDetector</code> NuGet package talking though, not me.
I built this package in hopes for it to become obsolete one day. Not because I expect the default of <code>dotnet pack</code> to ever change.
Clearly it won&rsquo;t. But I believe such warnings should be part of NuGet itself.</p><p>When you push a NuGet package to <em>nuget.org</em>, it should verify if the managed assemblies under <code>lib/</code> are indeed compiled with optimization, and if not, it should warn the author.
At the same time, when restoring such package, it should warn the consumer. This part in particular will make <code>UnoptimizedAssemblyDetector</code> redundant.</p><p>What else can <strong>we</strong> do? <a href=https://github.com/dotnet/nuget-trends>NuGet Trends</a> has the complete catalog. It could be extended to download the packages and inspect the assemblies in them. With that, create graphs and expose an endpoint to list unoptimized assemblies.</p><p>Well that, and ask the NuGet team to add these checks during package upload/restore.</p><p>&ndash;
Cover photo by <a href="https://unsplash.com/@amir_v_ali?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">amirali mirhashemian</a> on <a href="https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://garcia.in/tags/.net/>.NET</a></li><li><a href=https://garcia.in/tags/assembly/>Assembly</a></li><li><a href=https://garcia.in/tags/nuget/>NuGet</a></li><li><a href=https://garcia.in/tags/optimization/>Optimization</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://garcia.in>Bruno Garcia's blog</a></span></footer><button class=top-link id=top-link type=button aria-label="go to top" title="Go to Top" accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button>
<script defer src=https://garcia.in/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};mybutton.onclick=function(){document.body.scrollTop=0;document.documentElement.scrollTop=0;window.location.hash=''}
function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>